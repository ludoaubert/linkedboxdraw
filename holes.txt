1) prendre les données des rectangles de test
 vector<MyRect> rectangles
 le graphe logique est une donnée immuable.
 le graphe topologique egalement.
 tous les deux sont filtrable.
 le graphe topologique contient une information de distance. On ne garde les liens que si la distance est inférieure
 a un seuil.
2) calculer les trous, ne garder que les trous d'une certaine taille
 vector<MyRect> holes;
3) pour un ensemble {i,j,k} de rectangles selectionés comme déplacables, cet
 ensemble devient un autre ensemble de trous. Un ensemble qui ne change pas,
 et un ensemble qui change. L'ensemble des trous est donc constitué de 2 sous
 ensembles.
4) pour adresser un trou, il faut donc utiliser un doublet (Leg, i) (?)
5) vector<MyRect>* holes2[2] = {&holes, &rectangles}
6) calculer le graphe topologiques pour holes et tout les rectangles (un seul graphe)
 struct Edge{int LEG_i, i, LEG_j, j}
 vector<Edge> edges
 On pourra filtrer le graphe topologique
7) il faut aussi utiliser le graphe logique.
8) pour un ensemble {i,j,k} de rectangles selectionés comme déplacables, il faut selectionner
 le sous graphe logique correspondant.
9) chaque rectangle etant mappé sur une trou, le sous graphe logique doit être mappé depuis l'espace
logique vers l'espace topologique.
10) pour un ensemble {i,j,k} de rectangles selectionnés, pour chaque matching avec un ensemble de trous,
 il va falloir mapper le graphe logique vers le graphe topologique, et il va falloir trier les liens obtenus.
 Cela pour chaque match, ce qui promet d'etre couteux.
 
 Autre idee: pour chaque trou, garder de coté la liste de ses voisins.
 Un trou qui n'a aucun voisin interessant peut ne plus etre listé.
 Cela revient au meme. On va etre obligé de trier les listes de voisins lors des matchs.
 Ou alors peut-on les precalculer ?
 
 Individual rejection: si on prend un echantillon {i,j,k} matché sur {ti,tj,tk}, et que i est connecté à l tandis que
 ti n'est pas connecté à l, alors le match peut être rejeté directement. Idem pour j et k, ce qui fait que cela peut
 permettre de filtrer de nombreux matchs. Il faut peut-etre distinguer les liens intra echantillon (qui doivent etre mappés)
 et les liens entre l'echantillon et les autres rectangles.
 